---
title: "Architecture Overview"
description: "CLEO system architecture, design principles, and core components"
icon: "cubes"
---

# Architecture Overview

CLEO is a production-grade task management system designed specifically for AI coding agents. This document covers the core architecture and design principles.

## Design Principles

CLEO is built on three foundational pillars:

<CardGroup cols={3}>
  <Card title="Anti-Hallucination First" icon="shield-check">
    Multi-layer validation prevents AI-generated errors from corrupting task data
  </Card>
  <Card title="Atomic Operations" icon="atom">
    Every file modification uses atomic write patterns - no partial writes, no corruption
  </Card>
  <Card title="Session Continuity" icon="clock">
    Complete audit trails and automatic backups enable seamless work across sessions
  </Card>
</CardGroup>

## System Invariants

These properties must **ALWAYS** be true:

| Invariant | Description |
|-----------|-------------|
| Single Source of Truth | `tasks.db` (SQLite) is authoritative for active tasks |
| Immutable History | Log entries never modified or deleted |
| Fail-Safe Operations | Atomic file operations with validation |
| Schema-First | JSON Schema validation prevents corruption |
| Idempotent Scripts | Safe to run multiple times |
| Zero-Config Defaults | Sensible defaults, optional customization |

## Directory Structure

```
src/                        # TypeScript source
├── cli/                    # CLI entry point (Commander.js)
│   └── commands/           # 85+ command handlers (parse args -> core -> output)
├── core/                   # Shared business logic
│   ├── tasks/              # Task CRUD, hierarchy, dependencies
│   ├── sessions/           # Session lifecycle, focus tracking
│   ├── lifecycle/          # RCSD-IVTR lifecycle gates
│   ├── release/            # Release management
│   └── ...                 # validation, metrics, skills, etc.
├── mcp/                    # MCP server
│   ├── domains/            # MCP tool definitions and routing
│   └── engine/             # Adapters from MCP protocol to core
├── store/                  # Data access layer (SQLite, atomic ops, backup)
├── types/                  # Shared TypeScript type definitions
└── validation/             # Schema validation

.cleo/                      # Project-level data
├── tasks.db               # SQLite database (tasks, sessions, audit log)
├── config.json            # Project configuration (human-editable)
├── project-info.json      # Project metadata
├── schemas/               # JSON Schema definitions
└── .backups/              # Automatic backups
```

## Data Files

<AccordionGroup>
  <Accordion title="tasks.db (SQLite)" icon="database">
    **Purpose**: All operational data (source of truth)

    **Contains**: Tasks, sessions, audit log, lifecycle state, archived tasks -- all in a single SQLite database per ADR-006.
  </Accordion>

  <Accordion title="config.json" icon="gear">
    **Purpose**: Project configuration (human-editable)

    **Contains**: Archive settings, validation rules, defaults. One of the few JSON files retained for human editability.
  </Accordion>

  <Accordion title="project-info.json" icon="circle-info">
    **Purpose**: Project metadata

    **Contains**: Project name, detected type, registration info.
  </Accordion>
</AccordionGroup>

## Core Components

### Validation Pipeline

<Steps>
  <Step title="Schema Validation">
    JSON Schema validation on every write operation
  </Step>
  <Step title="Semantic Validation">
    Cross-file integrity checks, valid status transitions
  </Step>
  <Step title="Anti-Hallucination Checks">
    Duplicate detection, timestamp validation, ID uniqueness
  </Step>
  <Step title="Atomic Write">
    temp file → validate → backup → rename
  </Step>
</Steps>

### Atomic Write Pattern

All file modifications follow this pattern:

```
1. Write to temporary file
2. Validate against JSON Schema
3. Create backup of original
4. Atomic rename to replace original
5. Log operation to audit trail
```

<Info>
This pattern ensures no partial writes - either the entire operation succeeds or the original file is preserved.
</Info>

### Backup System

CLEO implements a two-tier backup system:

| Tier | Purpose | Location |
|------|---------|----------|
| **Tier 1** | Atomic write safety | `.cleo/.backups/` |
| **Tier 2** | Point-in-time recovery | `.cleo/backups/{type}/` |

**Tier 1** backups are automatic on every write operation with numbered rotation (last 10).

**Tier 2** backups are manual or pre-destructive operation snapshots with metadata and checksums.

## Anti-Hallucination Mechanisms

CLEO implements four layers of protection:

<Tabs>
  <Tab title="Layer 1: Schema">
    **JSON Schema Enforcement**

    Every task must conform to `todo.schema.json`:
    - Required fields: `id`, `title`, `status`
    - Status enum: `pending`, `active`, `blocked`, `done`
    - Valid timestamp formats
    - Correct data types
  </Tab>

  <Tab title="Layer 2: Semantic">
    **Cross-File Integrity**

    - ID uniqueness across active tasks and archive
    - No duplicate task descriptions
    - Valid parent references
    - Dependency cycle detection
  </Tab>

  <Tab title="Layer 3: Temporal">
    **Timestamp Validation**

    - No future timestamps
    - Logical ordering (created < modified)
    - Session boundary consistency
  </Tab>

  <Tab title="Layer 4: Content">
    **Content Validation**

    - Title differs from description
    - Action-oriented titles
    - Phase existence validation
    - Label format checking
  </Tab>
</Tabs>

## Extension Points

CLEO provides several extension mechanisms:

| Extension | Purpose | Location |
|-----------|---------|----------|
| Hooks | Pre/post operation callbacks | `hooks/` |
| Validators | Custom validation rules | `src/validation/` |
| MCP Domains | New MCP tool domains | `src/mcp/domains/` |
| Commands | New CLI commands | `src/cli/commands/` |

## Performance Considerations

CLEO is optimized for 1000+ tasks:

- **File locking** prevents race conditions
- **Indexed operations** for fast lookups
- **Lazy loading** for archive access
- **Native JSON parsing** via Node.js (no external dependencies)

## Next Steps

<CardGroup cols={2}>
  <Card title="Data Flows" icon="diagram-project" href="/concepts/data-flows">
    Visual workflows and operation diagrams
  </Card>
  <Card title="Anti-Hallucination" icon="shield" href="/concepts/anti-hallucination">
    Deep dive into validation mechanisms
  </Card>
</CardGroup>
