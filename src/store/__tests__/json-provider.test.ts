/**
 * Integration tests for JSON StoreProvider.
 *
 * Exercises the full JSON-backed StoreProvider through real core module
 * operations -- task CRUD, sessions, and focus -- against temp directories.
 *
 * @task T4645
 * @epic T4638
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdtemp, rm, writeFile, mkdir, readFile } from 'node:fs/promises';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import { createStoreProvider } from '../provider.js';
import { createJsonStoreProvider } from '../json-provider.js';
import { getStore } from '../index.js';
import { readJson } from '../json.js';
import type { StoreProvider } from '../provider.js';
import type { TodoFile } from '../../types/task.js';

/** Create a minimal tasks.json for testing. */
function makeTodoFile(tasks: TodoFile['tasks'] = []): TodoFile {
  return {
    version: '2.10.0',
    project: { name: 'test-project', phases: {} },
    lastUpdated: new Date().toISOString(),
    _meta: {
      schemaVersion: '2.10.0',
      checksum: '0000000000000000',
      configVersion: '1.0.0',
    },
    tasks,
  };
}

/** Set up a temp directory with .cleo structure for testing. */
async function setupTestDir(): Promise<{ tempDir: string; cleoDir: string }> {
  const tempDir = await mkdtemp(join(tmpdir(), 'cleo-json-provider-'));
  const cleoDir = join(tempDir, '.cleo');
  await mkdir(cleoDir, { recursive: true });
  await mkdir(join(cleoDir, 'backups', 'operational'), { recursive: true });
  await writeFile(join(cleoDir, 'tasks.json'), JSON.stringify(makeTodoFile()));
  await writeFile(join(cleoDir, 'todo-log.jsonl'), '');
  // Sequence file needed for ID generation and safety validation
  await writeFile(join(cleoDir, '.sequence.json'), JSON.stringify({ counter: 0, lastId: 'T000', checksum: 'init' }));
  return { tempDir, cleoDir };
}

describe('createStoreProvider json factory', () => {
  let tempDir: string;
  let cleoDir: string;

  beforeEach(async () => {
    ({ tempDir, cleoDir } = await setupTestDir());
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  it('createStoreProvider("json") returns a valid provider', async () => {
    const provider = await createStoreProvider('json', tempDir);
    expect(provider).toBeDefined();
    expect(provider.engine).toBe('json');
    await provider.close();
  });

  it('getStore returns a provider with auto-detected engine', async () => {
    const provider = await getStore(tempDir);
    expect(provider).toBeDefined();
    expect(provider.engine).toBe('json');
    await provider.close();
  });
});

describe('JSON StoreProvider task CRUD', () => {
  let tempDir: string;
  let cleoDir: string;
  let provider: StoreProvider;

  beforeEach(async () => {
    ({ tempDir, cleoDir } = await setupTestDir());
    provider = createJsonStoreProvider(tempDir);
  });

  afterEach(async () => {
    await provider.close();
    await rm(tempDir, { recursive: true, force: true });
  });

  it('createTask creates a task and returns it', async () => {
    const task = await provider.createTask({
      id: '', // ID is generated by addTask
      title: 'Test task from provider',
      status: 'pending',
      priority: 'medium',
      createdAt: new Date().toISOString(),
    });

    expect(task).toBeDefined();
    expect(task.id).toMatch(/^T\d{3,}$/);
    expect(task.title).toBe('Test task from provider');
    expect(task.status).toBe('pending');
    expect(task.priority).toBe('medium');
  });

  it('getTask retrieves a created task', async () => {
    const created = await provider.createTask({
      id: '',
      title: 'Retrievable task',
      status: 'pending',
      priority: 'high',
      createdAt: new Date().toISOString(),
    });

    const fetched = await provider.getTask(created.id);
    expect(fetched).not.toBeNull();
    expect(fetched!.id).toBe(created.id);
    expect(fetched!.title).toBe('Retrievable task');
    expect(fetched!.priority).toBe('high');
  });

  it('getTask returns null for non-existent task', async () => {
    const result = await provider.getTask('T99999');
    expect(result).toBeNull();
  });

  it('updateTask modifies a task', async () => {
    const created = await provider.createTask({
      id: '',
      title: 'Task to update',
      status: 'pending',
      priority: 'low',
      createdAt: new Date().toISOString(),
    });

    const updated = await provider.updateTask(created.id, {
      title: 'Updated task title',
      priority: 'high',
    });

    expect(updated).not.toBeNull();
    expect(updated!.title).toBe('Updated task title');
    expect(updated!.priority).toBe('high');

    // Verify by re-fetching
    const fetched = await provider.getTask(created.id);
    expect(fetched!.title).toBe('Updated task title');
  });

  it('updateTask returns null for non-existent task', async () => {
    const result = await provider.updateTask('T99999', { title: 'Nope' });
    expect(result).toBeNull();
  });

  it('deleteTask removes a task', async () => {
    const created = await provider.createTask({
      id: '',
      title: 'Task to delete',
      status: 'pending',
      priority: 'medium',
      createdAt: new Date().toISOString(),
    });

    const deleted = await provider.deleteTask(created.id);
    expect(deleted).toBe(true);

    // Verify it's gone from active tasks
    const fetched = await provider.getTask(created.id);
    expect(fetched).toBeNull();
  });

  it('deleteTask returns false for non-existent task', async () => {
    const result = await provider.deleteTask('T99999');
    expect(result).toBe(false);
  });

  it('listTasks returns all tasks', async () => {
    await provider.createTask({
      id: '',
      title: 'Task A',
      status: 'pending',
      priority: 'medium',
      createdAt: new Date().toISOString(),
    });
    await provider.createTask({
      id: '',
      title: 'Task B',
      status: 'active',
      priority: 'high',
      createdAt: new Date().toISOString(),
    });

    const tasks = await provider.listTasks();
    expect(tasks).toHaveLength(2);
    const titles = tasks.map(t => t.title).sort();
    expect(titles).toEqual(['Task A', 'Task B']);
  });

  it('listTasks filters by status', async () => {
    await provider.createTask({
      id: '',
      title: 'Pending task',
      status: 'pending',
      priority: 'medium',
      createdAt: new Date().toISOString(),
    });
    await provider.createTask({
      id: '',
      title: 'Active task',
      status: 'active',
      priority: 'medium',
      createdAt: new Date().toISOString(),
    });

    const pending = await provider.listTasks({ status: 'pending' });
    expect(pending).toHaveLength(1);
    expect(pending[0]!.title).toBe('Pending task');
  });

  it('findTasks does fuzzy search', async () => {
    await provider.createTask({
      id: '',
      title: 'Implement authentication',
      status: 'pending',
      priority: 'medium',
      createdAt: new Date().toISOString(),
    });
    await provider.createTask({
      id: '',
      title: 'Fix database connection',
      status: 'pending',
      priority: 'medium',
      createdAt: new Date().toISOString(),
    });

    const results = await provider.findTasks('authentication');
    expect(results.length).toBeGreaterThanOrEqual(1);
    expect(results[0]!.title).toBe('Implement authentication');
  });

  it('archiveTask moves a done task to archive', async () => {
    const created = await provider.createTask({
      id: '',
      title: 'Task to archive',
      status: 'pending',
      priority: 'medium',
      createdAt: new Date().toISOString(),
    });

    // Mark as done first
    await provider.updateTask(created.id, { status: 'done' });

    const archived = await provider.archiveTask(created.id);
    expect(archived).toBe(true);

    // Verify it's gone from active tasks
    const fetched = await provider.getTask(created.id);
    expect(fetched).toBeNull();

    // Verify it's in the archive
    const archiveData = await readJson<{ archivedTasks: Array<{ id: string }> }>(
      join(cleoDir, 'tasks-archive.json'),
    );
    expect(archiveData).not.toBeNull();
    expect(archiveData!.archivedTasks.some(t => t.id === created.id)).toBe(true);
  });

  it('archiveTask returns false for non-existent task', async () => {
    const result = await provider.archiveTask('T99999');
    expect(result).toBe(false);
  });
});

describe('JSON StoreProvider round-trip data integrity', () => {
  let tempDir: string;
  let cleoDir: string;
  let provider: StoreProvider;

  beforeEach(async () => {
    ({ tempDir, cleoDir } = await setupTestDir());
    provider = createJsonStoreProvider(tempDir);
  });

  afterEach(async () => {
    await provider.close();
    await rm(tempDir, { recursive: true, force: true });
  });

  it('create via provider -> read via readJson -> data matches', async () => {
    const created = await provider.createTask({
      id: '',
      title: 'Round-trip test',
      status: 'pending',
      priority: 'high',
      description: 'Testing data integrity',
      createdAt: new Date().toISOString(),
    });

    // Read raw JSON file
    const rawData = await readJson<TodoFile>(join(cleoDir, 'tasks.json'));
    expect(rawData).not.toBeNull();
    const rawTask = rawData!.tasks.find(t => t.id === created.id);
    expect(rawTask).toBeDefined();
    expect(rawTask!.title).toBe('Round-trip test');
    expect(rawTask!.priority).toBe('high');
    expect(rawTask!.description).toBe('Testing data integrity');
  });

  it('multiple operations maintain data consistency', async () => {
    // Create
    const t1 = await provider.createTask({
      id: '',
      title: 'First',
      status: 'pending',
      priority: 'medium',
      createdAt: new Date().toISOString(),
    });
    const t2 = await provider.createTask({
      id: '',
      title: 'Second',
      status: 'pending',
      priority: 'low',
      createdAt: new Date().toISOString(),
    });

    // Update
    await provider.updateTask(t1.id, { status: 'active' });

    // Verify via raw file read
    const rawData = await readJson<TodoFile>(join(cleoDir, 'tasks.json'));
    expect(rawData).not.toBeNull();
    expect(rawData!.tasks).toHaveLength(2);

    const raw1 = rawData!.tasks.find(t => t.id === t1.id);
    expect(raw1!.status).toBe('active');

    const raw2 = rawData!.tasks.find(t => t.id === t2.id);
    expect(raw2!.status).toBe('pending');
  });
});

describe('JSON StoreProvider session operations', () => {
  let tempDir: string;
  let cleoDir: string;
  let provider: StoreProvider;

  beforeEach(async () => {
    ({ tempDir, cleoDir } = await setupTestDir());
    provider = createJsonStoreProvider(tempDir);
  });

  afterEach(async () => {
    await provider.close();
    await rm(tempDir, { recursive: true, force: true });
  });

  it('createSession creates a new session', async () => {
    const session = await provider.createSession({
      id: '',
      name: 'Test Session',
      status: 'active',
      scope: { type: 'global' },
      focus: { taskId: null, setAt: null },
      startedAt: new Date().toISOString(),
    });

    expect(session).toBeDefined();
    expect(session.id).toBeTruthy();
    expect(session.name).toBe('Test Session');
    expect(session.status).toBe('active');
  });

  it('getSession retrieves an existing session', async () => {
    const created = await provider.createSession({
      id: '',
      name: 'Findable Session',
      status: 'active',
      scope: { type: 'global' },
      focus: { taskId: null, setAt: null },
      startedAt: new Date().toISOString(),
    });

    const fetched = await provider.getSession(created.id);
    expect(fetched).not.toBeNull();
    expect(fetched!.id).toBe(created.id);
    expect(fetched!.name).toBe('Findable Session');
  });

  it('getSession returns null for non-existent session', async () => {
    const result = await provider.getSession('session-nonexistent');
    expect(result).toBeNull();
  });

  it('listSessions returns all sessions', async () => {
    // Create a session (we can only have one active per scope)
    await provider.createSession({
      id: '',
      name: 'Session A',
      status: 'active',
      scope: { type: 'global' },
      focus: { taskId: null, setAt: null },
      startedAt: new Date().toISOString(),
    });

    const sessions = await provider.listSessions();
    expect(sessions.length).toBeGreaterThanOrEqual(1);
    expect(sessions.some(s => s.name === 'Session A')).toBe(true);
  });

  it('endSession ends an active session', async () => {
    const created = await provider.createSession({
      id: '',
      name: 'Session to End',
      status: 'active',
      scope: { type: 'global' },
      focus: { taskId: null, setAt: null },
      startedAt: new Date().toISOString(),
    });

    const ended = await provider.endSession(created.id, 'Done for now');
    expect(ended).not.toBeNull();
    expect(ended!.status).toBe('ended');
  });

  it('endSession returns null for non-existent session', async () => {
    const result = await provider.endSession('session-nonexistent');
    expect(result).toBeNull();
  });
});

describe('JSON StoreProvider focus operations', () => {
  let tempDir: string;
  let cleoDir: string;
  let provider: StoreProvider;

  beforeEach(async () => {
    ({ tempDir, cleoDir } = await setupTestDir());
    provider = createJsonStoreProvider(tempDir);
  });

  afterEach(async () => {
    await provider.close();
    await rm(tempDir, { recursive: true, force: true });
  });

  it('setFocus and getFocus round-trip', async () => {
    // Create a task to focus on
    const task = await provider.createTask({
      id: '',
      title: 'Focus target',
      status: 'pending',
      priority: 'medium',
      createdAt: new Date().toISOString(),
    });

    // Set focus
    await provider.setFocus('session-1', task.id);

    // Get focus (JSON provider ignores sessionId)
    const focus = await provider.getFocus('session-1');
    expect(focus.taskId).toBe(task.id);
  });

  it('clearFocus removes focus', async () => {
    // Create a task and set focus
    const task = await provider.createTask({
      id: '',
      title: 'Focus to clear',
      status: 'pending',
      priority: 'medium',
      createdAt: new Date().toISOString(),
    });

    await provider.setFocus('session-1', task.id);

    // Clear focus
    await provider.clearFocus('session-1');

    // Verify
    const focus = await provider.getFocus('session-1');
    expect(focus.taskId).toBeNull();
  });

  it('getFocus returns null taskId when no focus set', async () => {
    const focus = await provider.getFocus('session-1');
    expect(focus.taskId).toBeNull();
  });
});
